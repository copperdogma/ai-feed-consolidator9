# Story: Local PostgreSQL and Schema Implementation

**Status**: Done

---

## Related Requirement
This story relates to the content management requirements in the [Key Features](../requirements.md#key-features) section of the requirements document, particularly the need to store and manage content from various sources.

## Alignment with Design
This story aligns with the [Database](../design.md#database) section of the design document which specifies using a local PostgreSQL database (not containerized) and the [Database Schema](../architecture.md#database-schema) section of the architecture document.

## Acceptance Criteria
- ✅ Local PostgreSQL instance is set up and configured
- ✅ Database schema is fully defined in Prisma format
- ✅ All necessary tables are created with proper relationships
- ✅ Migrations are set up for version control (using `prisma db push` for development)
- ✅ Data access layer is implemented with Prisma
- ✅ Repository pattern is implemented for data access
- ✅ Docker containers can successfully connect to the local database
- ✅ Schema supports all required features:
  - ✅ User management
  - ✅ Source configuration
  - ✅ Content storage
  - ✅ Summary storage
  - ✅ Topic management
  - ✅ Activity tracking

## Schema Documentation

The database schema has been designed to support all the required features of the AI Feed Consolidator application:

### Enums

#### `SourceType`
- `RSS` - RSS and Atom feed sources
- `YOUTUBE` - YouTube platform sources (Watch Later, playlists)
- `TWITTER` - X/Twitter platform sources (bookmarks)
- `EMAIL` - Email-based content sources

#### `ContentStatus`
- `UNREAD` - Content that has not been viewed/read yet
- `READ` - Content that has been viewed/read
- `ARCHIVED` - Content that has been archived for later reference
- `DELETED` - Content marked for deletion (soft delete)

#### `ContentPriority`
- `LOW` - Low priority content
- `MEDIUM` - Medium priority content (default)
- `HIGH` - High priority content
- `URGENT` - Urgent content requiring immediate attention

### Core Models

#### `User`
Represents an application user (primarily the owner, with possible family members).
- `id`: UUID primary key
- `email`: Unique email address
- `name`: Optional user name
- `firebaseUid`: Unique Firebase Authentication ID
- `avatar`: Optional URL to user avatar/profile picture
- `isActive`: Boolean flag for account status
- `createdAt`: Timestamp when the record was created
- `updatedAt`: Timestamp when the record was last updated
- Relations:
  - `password`: One-to-one relation to Password model
  - `sources`: One-to-many relation to Source model
  - `activities`: One-to-many relation to Activity model

#### `Password`
Password hash storage (used alongside Firebase Authentication).
- `hash`: Hashed password
- `userId`: Foreign key to User model
- Relations:
  - `user`: Many-to-one relation to User model

#### `Source`
Represents a content source (RSS feed, YouTube playlist, Twitter bookmark list, etc.).
- `id`: UUID primary key
- `name`: Display name for the source
- `url`: Source URL
- `sourceType`: Enum for source type (RSS, YOUTUBE, TWITTER, EMAIL)
- `userId`: Foreign key to User model
- `icon`: Optional URL to source icon
- `isActive`: Boolean flag for active/inactive status
- `refreshRate`: Refresh interval in minutes (default: 60)
- `lastFetched`: Timestamp of last content fetch
- `settings`: JSON field for source-specific settings
- `createdAt`: Timestamp when the record was created
- `updatedAt`: Timestamp when the record was last updated
- Relations:
  - `user`: Many-to-one relation to User model
  - `contents`: One-to-many relation to Content model

#### `Content`
Represents a content item from a source (article, video, tweet, email, etc.).
- `id`: UUID primary key
- `title`: Content title
- `url`: Optional URL to the original content
- `contentText`: Optional full text content
- `contentHtml`: Optional HTML version of content
- `sourceId`: Foreign key to Source model
- `author`: Optional content author
- `publishedAt`: Original publication timestamp
- `status`: Enum for content status (UNREAD, READ, ARCHIVED, DELETED)
- `priority`: Enum for content priority (LOW, MEDIUM, HIGH, URGENT)
- `metadata`: JSON field for platform-specific metadata
- `isDeleted`: Boolean flag for soft deletion
- `createdAt`: Timestamp when the record was created
- `updatedAt`: Timestamp when the record was last updated
- Relations:
  - `source`: Many-to-one relation to Source model
  - `summary`: One-to-one relation to Summary model
  - `activities`: One-to-many relation to Activity model
  - `contentTopics`: One-to-many relation to ContentTopic model

#### `Summary`
Represents an AI-generated summary of a content item.
- `id`: UUID primary key
- `contentId`: Foreign key to Content model (unique)
- `summaryText`: Summary text generated by AI
- `createdAt`: Timestamp when the record was created
- `updatedAt`: Timestamp when the record was last updated
- Relations:
  - `content`: One-to-one relation to Content model

#### `Topic`
Represents a topic category for content organization.
- `id`: UUID primary key
- `name`: Unique topic name
- `description`: Optional topic description
- `createdAt`: Timestamp when the record was created
- `updatedAt`: Timestamp when the record was last updated
- Relations:
  - `contentTopics`: One-to-many relation to ContentTopic model

#### `ContentTopic`
Junction table for many-to-many relationship between Content and Topic.
- `contentId`: Foreign key to Content model (part of composite primary key)
- `topicId`: Foreign key to Topic model (part of composite primary key)
- `assignedAt`: Timestamp when the topic was assigned
- Relations:
  - `content`: Many-to-one relation to Content model
  - `topic`: Many-to-one relation to Topic model

#### `Activity`
Tracks user activities and content interactions.
- `id`: UUID primary key
- `userId`: Foreign key to User model
- `contentId`: Optional foreign key to Content model
- `action`: String defining the activity (read, archive, mark_priority, etc.)
- `details`: JSON field for additional activity details
- `createdAt`: Timestamp when the activity occurred
- Relations:
  - `user`: Many-to-one relation to User model
  - `content`: Many-to-one relation to Content model (nullable)

### Design Considerations
- UUID is used for primary keys to avoid exposure of sequential IDs
- Created and updated timestamps are included on all models
- Soft deletion is implemented for critical data via isDeleted flags
- JSON fields are used for flexible metadata storage
- Enums are used for predefined values (SourceType, ContentStatus, ContentPriority)
- Proper relationships are defined with appropriate cascade behaviors
- Efficient indexes are included for common query patterns
- The schema is designed to be extensible for future enhancements

## Repository Pattern Implementation

The repository pattern has been implemented to provide a clean abstraction over the database access layer:

### Base Repository
- Abstract class defining common CRUD operations for all entity types
- Methods: findById, findAll, create, update, delete, count

### Entity-Specific Repositories
- **UserRepository**: For user management (findByEmail, findByFirebaseUid, updateProfile)
- **SourceRepository**: For content sources (findByUserId, findByType, findSourcesToRefresh)
- **ContentRepository**: For content items (findBySourceId, findByStatus, findByPriority, search)
- **SummaryRepository**: For content summaries (findByContentId)
- **TopicRepository**: For content topics (findByName, findByContentId)
- **ContentTopicRepository**: For content-topic associations (associate, disassociate)
- **ActivityRepository**: For user activities (findByUserId, findByContentId, findByAction)

### Repository Factory
- Centralized management of repository instances
- Singleton pattern for each repository
- Provides consistent Prisma client instance sharing

## Tasks
- [x] Set up local PostgreSQL:
  - [x] Install PostgreSQL locally (already installed)
  - [x] Create development database (`ai_feed_consolidator`)
  - [x] Create test database (`ai_feed_test`)
  - [x] Configure PostgreSQL to allow connections from Docker containers
  - [x] Set up a database user with appropriate permissions
- [x] Set up Prisma ORM:
  - [x] Install Prisma CLI and dependencies
  - [x] Initialize Prisma in the project
  - [x] Configure database connection to local PostgreSQL
- [x] Update Docker configuration:
  - [x] Remove PostgreSQL service from docker-compose.yaml
  - [x] Update connection strings to point to host machine's PostgreSQL
  - [x] Configure networking to allow container-to-host communication
- [x] Implement core schema models:
  - [x] User model for Firebase Authentication integration
  - [x] Source model for content sources
  - [x] Content model for storing content items
  - [x] Summary model for storing AI-generated summaries
  - [x] Topic model for content categorization
  - [x] ContentTopic junction model for many-to-many relationships
  - [x] Activity model for tracking user actions
- [x] Define relationships between models:
  - [x] User to Source (one-to-many)
  - [x] Source to Content (one-to-many)
  - [x] Content to Summary (one-to-one)
  - [x] Content to Topic (many-to-many via ContentTopic)
  - [x] User to Activity (one-to-many)
  - [x] Content to Activity (one-to-many)
- [x] Configure PostgreSQL-specific features:
  - [x] Set up full-text search indexes (via PostgreSQL's capabilities)
  - [x] Configure JSON column types for metadata
  - [x] Set up efficient indexes for common query patterns
- [x] Create migration and apply it:
  - [x] Generate migration files (used db push instead for now)
  - [x] Validate migration SQL
  - [x] Apply migration to development database
- [x] Implement repository pattern:
  - [x] Create base repository interface
  - [x] Implement repositories for each entity:
    - [x] User repository
    - [x] Source repository 
    - [x] Content repository
    - [x] Summary repository
    - [x] Topic repository
    - [x] ContentTopic repository
    - [x] Activity repository
  - [x] Create repository factory for centralized management
  - [x] Add transaction support
- [x] Create database seeding:
  - [x] Create seed script for development data
  - [x] Implement data generators for testing
  - [x] Create database reset script
- [x] Document schema:
  - [x] Create detailed schema documentation
  - [x] Create Entity-Relationship Diagram (ERD)
  - [x] Document relationships and constraints
- [x] Test the database implementation:
  - [x] Verify connection from Docker containers
  - [x] Test CRUD operations for all models
  - [x] Test transactions for atomic operations
  - [x] Test relationships and constraints
- [x] Document the implementation in the project README
  - [x] Database architecture section
  - [x] Repository pattern details
  - [x] Authentication system integration
  - [x] Database migration instructions

## Completion Notes

Story 002 has been completed successfully. The database schema has been fully implemented and tested, with all acceptance criteria met. The repository pattern has been implemented for data access, with full transaction support. The database schema has been documented in detail, including an Entity-Relationship Diagram (ERD).

The implementation provides a solid foundation for the subsequent stories, particularly Story 002.1 (User Profile Management), which will build on the database schema and repository pattern implementation.

Key accomplishments:
- Comprehensive PostgreSQL schema with all required models and relationships
- Repository pattern implementation with transaction support
- Database seeding with realistic test data
- Full documentation of the database schema and repository pattern
- Integration with Firebase Authentication
- Strong TypeScript typing for database operations
- Comprehensive testing of relationships and constraints 